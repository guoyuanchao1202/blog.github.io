<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Java的I/O系统涉及了大量的类，本文只是简单的了解其中一些类的用法和分类，不涉及深层次的分析。">
<meta name="keywords" content="读书笔记,I&#x2F;O,Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈Java I&#x2F;O系统">
<meta property="og:url" content="https://blog.github.io/2019/10/27/浅谈Java-I-O系统/index.html">
<meta property="og:site_name" content="CommonGuy">
<meta property="og:description" content="Java的I/O系统涉及了大量的类，本文只是简单的了解其中一些类的用法和分类，不涉及深层次的分析。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-10-28T15:25:09.636Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈Java I&#x2F;O系统">
<meta name="twitter:description" content="Java的I/O系统涉及了大量的类，本文只是简单的了解其中一些类的用法和分类，不涉及深层次的分析。">
  <link rel="canonical" href="https://blog.github.io/2019/10/27/浅谈Java-I-O系统/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>浅谈Java I/O系统 | CommonGuy</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/HoA-W" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CommonGuy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://blog.github.io/2019/10/27/浅谈Java-I-O系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭源潮">
      <meta itemprop="description" content="时间在无声的诉说着一切">
      <meta itemprop="image" content="/images/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CommonGuy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">浅谈Java I/O系统

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-27 08:30:49" itemprop="dateCreated datePublished" datetime="2019-10-27T08:30:49+08:00">2019-10-27</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-28 23:25:09" itemprop="dateModified" datetime="2019-10-28T23:25:09+08:00">2019-10-28</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java编程思想/" itemprop="url" rel="index"><span itemprop="name">Java编程思想</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Java的I/O系统涉及了大量的类，本文只是简单的了解其中一些类的用法和分类，不涉及深层次的分析。</p>
<hr>
<a id="more"></a>

<h1 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h1><p>Java的I/O库系统也使用流这个概念，它代表任何有能力产出数据源对象或是有能力接收数据的接收端对象。“流”屏蔽了实际I/O设备中处理数据的细节。<br>Java类库中的I/O类分为输入和输出两部分，通过JDK可以查阅到，任何InputStream或Reader派生的子类都有read()方法，用于读取单个字节或者字节数组。同样的任何OutputStream或Writer派生的子类都有Write()方法，用于写单个字节或字节数组。</p>
<h2 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a><font size="5">InputStream类型</font></h2><p>InputStream的作用是用来表示那些从不同数据源产生输入的类，这些数据源包括：</p>
<ul>
<li>字节数组</li>
<li>文件</li>
<li>“管道”，工作方式与实际管道类似，即从一端输入，从另一端输出</li>
<li>一个由其他流组成的序列，以便我们可以将它们收集合并到一个流内</li>
<li>其他数据源，如网络等</li>
</ul>
<p>每一种数据源都有相应的InputStream子类。另外FilterInputStreamu也属于一种InputStream，为“装饰器”类提供基类。</p>
<h3 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a><font size="5">ByteArrayInputStream</font></h3><ul>
<li><b>构造方法</b><br>传递一个字节数组作为其缓冲区<br>ByteArrayInputStream(byte[] buf)<br>ByteArrayInputStream(byte[] buf, int offset, int length) </li>
<li><b>作用</b><br>将其缓冲区(构造参数的字节数组)作为数据源，从中读取数据进输入流。</li>
<li><b>常用方法</b><ul>
<li>int available()<br>在没有阻塞的情况下所能读取的字节数。对于文件来说，就是整个文件</li>
<li>void mark(int readAheadLimit)<br>设置流中的当前标记位置。 </li>
<li>void reset()<br>将缓冲区的位置重置为标记位置。和mark()搭配使用。</li>
<li>boolean markSupported()<br>测试此 InputStream 是否支持 mark/reset。 </li>
<li>long skip(long n)<br>从此输入流中跳过 n 个输入字节。 </li>
</ul>
</li>
</ul>
<p><b>测试代码</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">byte[] res = &quot;Hello ByteArrayInputStream&quot;.getBytes();</span><br><span class="line">//使用字节数组作为缓冲区</span><br><span class="line">ByteArrayInputStream bin = new ByteArrayInputStream(res);</span><br><span class="line">int count=0;</span><br><span class="line">//利用available()方法判断是否到数据源末尾</span><br><span class="line">while (bin.available() != 0) &#123;</span><br><span class="line">	char ch = (char) bin.read();</span><br><span class="line">	count++;</span><br><span class="line">	//在空格字符后面做标记</span><br><span class="line">	if(ch==&apos; &apos;)</span><br><span class="line">		bin.mark(count+1);</span><br><span class="line">	System.out.print(ch);</span><br><span class="line">	//当第一次读到数据源末尾时将缓冲区位置重置到标记位置</span><br><span class="line">	if (bin.available() == 0&amp;&amp;count&lt;res.length+1) &#123;</span><br><span class="line">		System.out.println();</span><br><span class="line">		bin.reset();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“===========================”</span><br><span class="line">Output：</span><br><span class="line">Hello ByteArrayInputStream</span><br><span class="line">ByteArrayInputStream</span><br></pre></td></tr></table></figure>

<h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a><font size="5">FileInputStream</font></h3><p>将文件作为其数据源，通过构造方法绑定一个文件。<br>方法和ByteArrayInputStream类似，比较常用也比较简单</p>
<h3 id="PipedInputStream"><a href="#PipedInputStream" class="headerlink" title="PipedInputStream"></a><font size="5">PipedInputStream</font></h3><p>产生用于写入相关PipedOutputStream的数据，实现管道化概念</p>
<ul>
<li><b>构造方法</b><ul>
<li>PipedInputStream()<br>创建尚未连接的 PipedInputStream。 </li>
<li>PipedInputStream(PipedOutputStream src)<br>创建 PipedInputStream，以使其连接到传送输出流 src。 </li>
</ul>
</li>
<li><b>作用</b><br>多用于多线程环境。数据由某个线程从 PipedInputStream 对象读取，并由其他线程将其写入到相应的 PipedOutputStream。不建议对这两个对象尝试使用单个线程，因为这样可能会死锁该线程。传送输入流包含一个缓冲区，可在缓冲区限定的范围内将读操作和写操作分离开。 </li>
<li><b>常用方法</b><ul>
<li>void connect(PipedOutputStream src)<br>使此传送输入流连接到传送输出流 src。如果使用无参构造方法创建了一个尚未连接的流，那么要先调用该方法和一个输出流连接</li>
<li>int available()<br>返回可以不受阻塞地从此输入流中读取的字节数量。 </li>
</ul>
</li>
</ul>
<p><b>测试代码</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//创建一个接收线程</span><br><span class="line">public class Receiver implements Runnable &#123;</span><br><span class="line">    public PipedInputStream in = new PipedInputStream();</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">			将管道中的数据读取出来</span><br><span class="line">            System.out.println(&quot;开始使用管道流&quot;);</span><br><span class="line">            System.out.println(new String(in.readAllBytes()));</span><br><span class="line">            System.out.println(&quot;数据接收完毕&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建一个发送线程</span><br><span class="line">public class Sender implements Runnable &#123;</span><br><span class="line">    public PipedOutputStream out = new PipedOutputStream();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String msg = &quot;Hello Receiver&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">			//将数据写入到输出流中</span><br><span class="line">            out.write(msg.getBytes());</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主线程</span><br><span class="line">public class Piped &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        Sender send=new Sender();</span><br><span class="line">        Receiver rece = new Receiver();</span><br><span class="line">        //连接管道</span><br><span class="line">        send.out.connect(rece.in);</span><br><span class="line">        //rece.in.connect(send);    两种方式效果都一样</span><br><span class="line">        //先启动发送线程</span><br><span class="line">        new Thread(send).start();</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        new Thread(rece).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“=====================”</span><br><span class="line">Output：</span><br><span class="line">开始使用管道流</span><br><span class="line">Hello Receiver</span><br><span class="line">数据接收完毕</span><br></pre></td></tr></table></figure>

<p>在本例中，是由一个线程使用管道输出流将数据写入到流中，另一个线程使用管道输入流将数据从流中读取到内存。</p>
<h3 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a><font size="5">SequenceInputStream</font></h3><p>序列化流，将两个或多个InputStream对象传换成单一InputStream</p>
<ul>
<li><b>构造方法</b><br>SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e)<br>将多个输入流转换为单一输入流<br>SequenceInputStream(InputStream s1, InputStream s2)<br>将两个输入流转换为单一输入流</li>
<li><b>作用</b><br>表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。</li>
<li><b>常用方法</b><ul>
<li>int available()<br>返回当前流中可用的字节数。 </li>
</ul>
</li>
</ul>
<p><b>测试代码</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream bin1 = new ByteArrayInputStream(&quot;hello&quot;.getBytes());</span><br><span class="line">ByteArrayInputStream bin2 = new ByteArrayInputStream(&quot;SequenceInputStream&quot;.getBytes());</span><br><span class="line">//创建序列化流，将两个输入流转换成单一输入流</span><br><span class="line">SequenceInputStream in = new SequenceInputStream(bin1, bin2);</span><br><span class="line">int ch=0;</span><br><span class="line">//不能使用available()方法，否则只能读取第一个流的数据</span><br><span class="line">while ((ch = in.read()) != -1) &#123;</span><br><span class="line">	System.out.print((char)ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“=======================”</span><br><span class="line">Output：</span><br><span class="line">helloSequenceInputStream</span><br></pre></td></tr></table></figure>

<h2 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a><font size="5">OutputStream类型</font></h2><p>和InputStream类型对应的，也有几种输出流类型</p>
<h3 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a><font size="5">ByteArrayOutputStream</font></h3><ul>
<li><b>构造方法</b><br>ByteArrayOutputStream()<br>创建一个新的字节数组输出流。<br>ByteArrayOutputStream(int size)<br>创建一个新的字节数组输出流，它具有指定大小的缓冲区容量（以字节为单位）。 </li>
<li><b>作用</b><br>将数据写入到内部缓冲区中</li>
<li><b>常用方法</b><ul>
<li>String toString(String enc)<br>将缓冲区的内容转换为字符串，根据指定的字符编码将字节转换成字符 </li>
<li>byte[] toByteArray()<br>创建一个新分配的字节数组。 </li>
<li>String toString()<br>将缓冲区的内容转换为字符串，根据平台的默认字符编码将字节转换成字符。 </li>
</ul>
</li>
</ul>
<p><b>示例代码</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream bou = new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">int read;</span><br><span class="line">//从将控制台输入的数据写入到缓冲区中</span><br><span class="line">while ((read=System.in.read())!=10)&#123;</span><br><span class="line">	bou.write(read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将缓冲区数据转换为字符串输出</span><br><span class="line">System.out.println(bou.toString());</span><br><span class="line"></span><br><span class="line">“=================”</span><br><span class="line">Input：</span><br><span class="line">qwertyu</span><br><span class="line"></span><br><span class="line">Output：</span><br><span class="line">qwertyu</span><br></pre></td></tr></table></figure>

<h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a><font size="5">FileOutputStream</font></h3><p>比较常用，和FileInputStream对应使用。</p>
<h3 id="PipedOutputStream"><a href="#PipedOutputStream" class="headerlink" title="PipedOutputStream"></a><font size="5">PipedOutputStream</font></h3><p>和管道输入流搭配使用，示例代码见前面PipedInputStream流</p>
<h1 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h1><p>Jaav的I/O库需要多种不同功能的组合，这正是装饰器模式的理由所在。FilterInputStream和FilterOutputStream用于装饰InputStream和OutputStream字节流。它们分别继承自基类InputStream和OutputStream。</p>
<h2 id="通过FilterInputStream从InputStream读取数据"><a href="#通过FilterInputStream从InputStream读取数据" class="headerlink" title="通过FilterInputStream从InputStream读取数据"></a><font size="5">通过FilterInputStream从InputStream读取数据</font></h2><p>FilterInputStream有不同的子类，能够提供不同的功能</p>
<h3 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a><font size="5">DataInputStream</font></h3><ul>
<li><b>构造方法</b><br>传递一个InputStream实现类对象</li>
<li><b>作用</b><br>和DataOutputStream搭配使用，允许应用程序以与机器无关方式从基础输入流中读取基本Java数据类型和String类型。与机器无关的方式也就是说在不同的机器上使用该流传递数据都是正确的。</li>
<li><b>常用方法</b><ul>
<li><b>readxxx()</b><br>readByte、readShort…一系列的read方法以相应的方式从流中读取数据。读取的方法要和写入的方法对应(如果使用writeBoolean()写入，那么就要用readBoolean()读取)</li>
<li><b>readUTF</b><br>读取字符串数据</li>
</ul>
</li>
</ul>
<p><font color="blue">当使用readByte()读取数据时，每一个字节都是有效的，不能使用返回值是否为-1来判断是否读取到文件末尾，可以使用处理异常的方法或者是available()方法</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream din = new DataInputStream(new ByteArrayInputStream(</span><br><span class="line">		//这是自己写的一个类，read方法返回一个字符串，通过getBytes()得到byte数据传递给ByteArrayInputStream对象</span><br><span class="line">		BufferedInputFile.read(&quot;.\\src\\eighteenth\\formattedmemoryinput\\FormattedMemoryInput.java&quot;).getBytes()));</span><br><span class="line">//当使用readByte()方法一次一个字节的读取字符，那么任何字节的值都是合法效果</span><br><span class="line">//此时方法的返回值不能用来检测输入是否结束。这是我们有两种方法</span><br><span class="line">//这是第一种，使用捕获异常的方式来进行流控制(不是很推荐)</span><br><span class="line">//        try &#123;</span><br><span class="line">//            while (true) &#123;</span><br><span class="line">//                System.out.println((char) din.readByte());</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125; catch (EOFException e) &#123;</span><br><span class="line">//            System.out.println(&quot;End of Stream&quot;);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">//第二种方法，使用available()方法，该方法的字面意思就是</span><br><span class="line">//“在没有阻塞情况下所能读取的字节数</span><br><span class="line">while (din.available() != 0) &#123;</span><br><span class="line">	System.out.println((char) din.readByte());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a><font size="5">BufferedInputStream</font></h3><ul>
<li><b>构造方法</b><br>传递一个InputStream子类对象。</li>
<li><b>作用</b><br>对字节输入流进行缓冲，防止每次读写时都得进行实际操作，能够很好的加快读写速度。</li>
<li><b>常用方法</b><br>基本上和InputStream提供的方法一样</li>
</ul>
<h2 id="通过FilterOutputStream从OutputStream读取数据"><a href="#通过FilterOutputStream从OutputStream读取数据" class="headerlink" title="通过FilterOutputStream从OutputStream读取数据"></a><font size="5">通过FilterOutputStream从OutputStream读取数据</font></h2><p>和FilterInputStream对应的，FilterOutputStream也有一些子类，用于提供不同的功能</p>
<h3 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a><font size="5">DataOutputStream</font></h3><ul>
<li><b>构造方法</b><br>传递一个OutputStream实现类对象</li>
<li><b>作用</b><br>和DataInputStream一起使用，将各种基本数据类型以及String类型格式化输出到流中，这样一来，任何机器上的任何DataInputStream都能够读取它们。</li>
<li><b>常用方法</b><ul>
<li><b>writexxx()</b><br>以不同的方式将数据格式化写入到流中，当使用DataInputStream读取这些数据时，要使用和写入对应的读取方法。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//创建DataOutputStream对象，传递缓冲字节流</span><br><span class="line">DataOutputStream out = new DataOutputStream(</span><br><span class="line">		new BufferedOutputStream(</span><br><span class="line">				new FileOutputStream(&quot;.\\src\\eighteenth\\storingandrecoveringdata\\Data.txt&quot;)));</span><br><span class="line">out.writeDouble(3.1415926535);</span><br><span class="line">out.writeUTF(&quot;That was Pi&quot;);</span><br><span class="line">out.writeDouble(1.41413);</span><br><span class="line">out.writeUTF(&quot;Square root of 2&quot;);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">//创建DataInputStream对象，传递缓冲字节流</span><br><span class="line">DataInputStream in = new DataInputStream(</span><br><span class="line">		new BufferedInputStream(</span><br><span class="line">				new FileInputStream(&quot;.\\src\\eighteenth\\storingandrecoveringdata\\Data.txt&quot;)));</span><br><span class="line"></span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line"></span><br><span class="line">“===============”</span><br><span class="line">Output：</span><br><span class="line">3.1415926535</span><br><span class="line">That was Pi</span><br><span class="line">1.41413</span><br><span class="line">Square root of 2</span><br></pre></td></tr></table></figure>


<h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a><font size="5">PrintStream</font></h3><ul>
<li><b>构造方法</b><br>传递OutputStream子类对象或者直接传递文件对象或文件名</li>
<li><b>作用</b><br>用于产生格式化输出，PrintStream会捕获所有的IOException(因此必须使用checkError()自行测试错误状态，如果出现错误返回true)，PrintStream不能以平台无关的方式处理换行动作(PrintWriter可以)</li>
<li><b>常用方法</b><ul>
<li><b>println()</b><br>将数据输出到流中并换行</li>
<li><b>append()</b><br>向流中追加数据并返回该流</li>
</ul>
</li>
</ul>
<p>更多方法见API手册</p>
<h3 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a><font size="5">BufferedOutputStream</font></h3><ul>
<li><b>构造方法</b><br>传递一个OutputStream对象</li>
<li><b>作用</b><br>对OutputStream进行了修改，对数据流使用了缓冲技术，因此每次向流写入时，不必每次都进行实际的物理写动作，因此它的速度更快。一般在进行输出时，使用该流更多一些。</li>
</ul>
<h1 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h1><p>设计Reader和Writer继承层次结构主要是为了国际化，In/OutputStream只能处理8位字节流，并且不能很好的处理16位的Unicode字符。因此设计了Reader和Writer字符流<br>与InputStream以及OutputStream对应的，Reader和Writer也有相应的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot;========================================&quot;</span><br><span class="line">基类</span><br><span class="line">InputStream				Reader</span><br><span class="line">OutputStream				Writer</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">文件流</span><br><span class="line">FileInputStream				FileReader</span><br><span class="line">FileOutputStream			FileWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">数组流</span><br><span class="line">ByteArrayInputStream			CharArrayReader</span><br><span class="line">ByteArrayOutputStream			CharArrayWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">管道流</span><br><span class="line">PipedInputStream			PipedReader</span><br><span class="line">PipedOutputStream			PipedWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">转换流：字节流通向字符流的桥梁</span><br><span class="line">InputStreamReader</span><br><span class="line">OutputStreamWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">字符串流(字节流的已经废弃)</span><br><span class="line">StringReader</span><br><span class="line">StringWriter</span><br></pre></td></tr></table></figure>

<h1 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h1><p>对于InputStream和OutputStream来说，我们会使用FilterInputStream和FilterOutputStream装饰器的子类来对流添加一些功能。对于Reader和Writer，也会使用一些装饰器来改变流的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;========================================&quot;</span><br><span class="line">过滤器</span><br><span class="line">FilterInputStream			FilterReader</span><br><span class="line">FilterOutputStream			FilterWriter(抽象类，无子类)</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">缓冲流					直接继承自Reader和Writer</span><br><span class="line">BufferedInputStream			BufferedReader</span><br><span class="line">BufferedOutputStream			BufferedWriter</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">打印流					直接继承自Reader和Writer</span><br><span class="line">PrintStream				PrintWriter(构造参数技能接收Writer对象也能接收OutputStream对象)</span><br><span class="line"></span><br><span class="line">&quot;========================================&quot;</span><br><span class="line">数据流				</span><br><span class="line">DataInputStream				DataInputStream(当需要使用readLine()方法时应该使用BufferedReader)</span><br></pre></td></tr></table></figure>

<p>可以看出字符流装饰器的继承体系和字节流的有所不同(具体参考API类库)<br><font color="blue">有一点要注意：当我们需要使用readLine()方法时，一定不能使用DataInputStream，而应该使用BufferedReader。除了这一点，DataInputStream仍是首选。</font></p>
<h1 id="RandomAccessFle"><a href="#RandomAccessFle" class="headerlink" title="RandomAccessFle"></a>RandomAccessFle</h1><p>该流适用于由大小已知的记录组成的文件，我们可以使用seek()方法将记录从一处转移到另一处，然后读取和修改记录。<font color="blue">RandomAccessFile不是InputStream或者OutputStream继承层次体系结构中的一部分</font>。除了实现DataInput和DataOutput(DataInput/OutputStreamStream实现了这两个接口)之外，它和这两个继承层次结构没有任何关系。</p>
<ul>
<li><b>构造方法</b><br>RandomAccessFile(File file, String mode)<br>RandomAccessFile(String name, String mode)<br>传递文件对象或者文件路径名并指定模式(“r”随机读，”rw”既读由写)</li>
<li><b>作用</b><br>支持对随机存取文件的读取和写入</li>
<li><b>常用方法</b><ul>
<li><b>readxxx</b><br>以各种形式读取数据(类似于DataInputStream)</li>
<li><b>writexxx</b><br>以各种形式写入数据(类似于DataOutputStream)</li>
<li><b>read/writeUTF()</b><br>对字符串进行读写操作</li>
<li><b>seek()</b><br>将指针移到距离文件开头一定字节的偏移量，从此处开始读取数据<br>(更多方法参见API)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 使用RandomAccessFile对象，该对象类似于组合了DataInputStream和DataOutputStream</span><br><span class="line"> * (因为它实现了DataOut和DataInput接口)</span><br><span class="line"> * 该对象的seek()方法能够移动到文件的某个字节处。</span><br><span class="line"> *</span><br><span class="line"> * 如下，因为double是8字节，因此使用seek方法，将指针移动到第5个double值并修改它</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class UsingRandomAccessFile &#123;</span><br><span class="line">    static String file = &quot;.\\src\\eighteenth\\usingrandomaccessfile\\UsingRandomAccessFile.dat&quot;;</span><br><span class="line">    static void display() throws IOException &#123;</span><br><span class="line">        RandomAccessFile rf = new RandomAccessFile(file, &quot;r&quot;);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">            System.out.println(&quot;Value &quot; + i + &quot;: &quot; + rf.readDouble());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rf.readUTF());</span><br><span class="line">        rf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        RandomAccessFile rf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">            rf.writeDouble(i * 1.414);</span><br><span class="line">        &#125;</span><br><span class="line">        rf.writeUTF(&quot;The end of the file&quot;);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">        System.out.println(&quot;=================&quot;);</span><br><span class="line"></span><br><span class="line">        rf = new RandomAccessFile(file, &quot;rw&quot;);</span><br><span class="line">		//调用seek()方法</span><br><span class="line">        rf.seek(5 * 8);</span><br><span class="line">        rf.writeDouble(47.0001);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">”=====================“</span><br><span class="line">Output：</span><br><span class="line">Value 0: 0.0</span><br><span class="line">Value 1: 1.414</span><br><span class="line">Value 2: 2.828</span><br><span class="line">Value 3: 4.242</span><br><span class="line">Value 4: 5.656</span><br><span class="line">Value 5: 7.069999999999999</span><br><span class="line">Value 6: 8.484</span><br><span class="line">The end of the file</span><br><span class="line">=================</span><br><span class="line">Value 0: 0.0</span><br><span class="line">Value 1: 1.414</span><br><span class="line">Value 2: 2.828</span><br><span class="line">Value 3: 4.242</span><br><span class="line">Value 4: 5.656</span><br><span class="line">//使用seek()方法后指针移动到这里</span><br><span class="line">Value 5: 47.0001</span><br><span class="line">Value 6: 8.484</span><br><span class="line">The end of the file</span><br></pre></td></tr></table></figure>

<h1 id="I-O的典型使用方式"><a href="#I-O的典型使用方式" class="headerlink" title="I/O的典型使用方式"></a>I/O的典型使用方式</h1><p>我们可以通过不同的方式组合I/O流，但是我们可能用到的组合不多，介绍几种典型的组合</p>
<h2 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a><font size="5">缓冲输入文件</font></h2><p>如果要打开一个文件用于<b>字符输入</b></p>
<ol>
<li>可以使用String或者File对象作为文件名的FileReader。</li>
<li>为了提高速度，我们可以使用缓冲，因此可以将FileReader对象作为参数传递给BufferedReader构造器，得到一个BufferedReader对象。</li>
<li>并且该对象提供一个readLine()方法，当读取到文件末尾时，返回null。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//该read()方法传递一个文件名，返回文件的字符串表示</span><br><span class="line">public static String read(String filename) throws IOException &#123;</span><br><span class="line">	//创建缓冲字符输入流对象</span><br><span class="line">	BufferedReader br = new BufferedReader(new FileReader(filename));</span><br><span class="line">	String s;</span><br><span class="line">	StringBuilder sb = new StringBuilder();</span><br><span class="line">	//readLine()方法一次读取一行，但是不读取换行符，因此要自己加上&quot;\n&quot;</span><br><span class="line">	while ((s = br.readLine()) != null) &#123;</span><br><span class="line">		sb.append(s + &quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	br.close();</span><br><span class="line">	return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a><font size="5">从内存输入</font></h2><p>下面的示例中，从上面说的read方法中读入文件返回的String结果被用来创建一个StringReader，然后调用read()每次读取一个字符，并将它发送到控制台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从内存中读取数据，使用StringReader，构造参数传递一个字符串</span><br><span class="line"> * 使用StringReader对象的read方法从字符串中读取内容</span><br><span class="line"> */</span><br><span class="line">public class MemoryInput &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		//BufferedInputFile.read()即为上面介绍的从文件读取数据返回String对象</span><br><span class="line">		//利用String构造StringReader对象，从String中读取数据</span><br><span class="line">        StringReader sr = new StringReader(BufferedInputFile.read(&quot;.\\src\\eighteenth\\memoryinput\\MemoryInput.java&quot;));</span><br><span class="line">        int c;</span><br><span class="line">        while ((c = sr.read()) != -1) &#123;</span><br><span class="line">            System.out.println((char) c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="格式化内存输入"><a href="#格式化内存输入" class="headerlink" title="格式化内存输入"></a><font size="5">格式化内存输入</font></h2><p>要读取格式化数据，可以使用DataInputStream，这是一个面向字节的I/O类。因此我们要使用InputStream对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 格式化内存输入</span><br><span class="line"> * 要读取格式化数据，可以使用DataInputStream，它是一个字节流。</span><br><span class="line"> * 构造方法传递一个InputStream子类对象</span><br><span class="line"> * 这里传递的是ByteArrayInputStream对象</span><br><span class="line"> * 构造BytrArrayInputStream对象时传递一个字节数组，</span><br><span class="line"> * 该对象从字节数组中读取数据</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class FormattedMemoryInput &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		//同样的，BufferedInputFile.read()方法返回一个字符串</span><br><span class="line">        DataInputStream din = new DataInputStream(new ByteArrayInputStream(</span><br><span class="line">                BufferedInputFile.read(&quot;.\\src\\eighteenth\\formattedmemoryinput\\FormattedMemoryInput.java&quot;).getBytes()));</span><br><span class="line">		//前面说过，DataInputStream的readByte()方法读取的每一个字节都是有效的</span><br><span class="line">		//因此无法根据返回值来判断是否到达文件末尾，应该使用available()方法</span><br><span class="line">        while (din.available() != 0) &#123;</span><br><span class="line">            System.out.println((char) din.readByte());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a><font size="5">基本的文件输出</font></h2><p>FileWriter对象可以向文件写入数据。</p>
<ol>
<li>创建一个与指定文件绑定的FileWriter对象</li>
<li>为了将快速度，我们一般使用缓存，因此将该对象传递给BufferedWriter构造器，创建一个缓冲字符流对象</li>
<li>有时候为了提供格式化机制，还可以包装成PrintWriter。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static String filename = &quot;.\\src\\eighteenth\\basefileoutput\\BasicFileOutput.out&quot;;</span><br><span class="line">//创建缓冲字符流，传递一个Reader流对象，这里传递的是StringReader对象</span><br><span class="line">//创建StringReader对象时构造参数传递一个String，流从String中读取数据</span><br><span class="line">BufferedReader bin = new BufferedReader(new StringReader(</span><br><span class="line">		BufferedInputFile.read(&quot;.\\src\\eighteenth\\basefileoutput\\BasicFileOutput.java&quot;)));</span><br><span class="line"></span><br><span class="line">//创建FilterWriter流对象，传递一个Writer流对象，向文件中写入数据</span><br><span class="line">PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename)));</span><br><span class="line">int linecount = 1;</span><br><span class="line">String s;</span><br><span class="line">//使用该方法像文件中写入数据时，每写入一行数据会自动写入一个换行符</span><br><span class="line">while ((s = bin.readLine()) != null) &#123;</span><br><span class="line">	pw.println(linecount++ + &quot;: &quot; + s);</span><br><span class="line">&#125;</span><br><span class="line">pw.close();</span><br><span class="line">bin.close();</span><br></pre></td></tr></table></figure>

<h2 id="文件输出快捷方式"><a href="#文件输出快捷方式" class="headerlink" title="文件输出快捷方式"></a><font size="5">文件输出快捷方式</font></h2><p>在前面的示例中，为了使用带缓冲的PrintWriter，需要创建三各类来进行装饰，还有一种简单方法，直接给PrintWriter传递文件名或File对象，PrintWriter利用该构造器自己实现缓冲。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader bin = new BufferedReader(</span><br><span class="line">		new StringReader(BufferedInputFile.read(srcfilename))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//直接传递文件名，船舰带缓存的打印流对象</span><br><span class="line">PrintWriter pou = new PrintWriter(desfilename);</span><br><span class="line">int linecount = 1;</span><br><span class="line">String res;</span><br><span class="line">while ((res = bin.readLine()) != null) &#123;</span><br><span class="line">	pou.println(linecount++ + &quot;: &quot; + res);</span><br><span class="line">&#125;</span><br><span class="line">//使用完后关闭流</span><br><span class="line">pou.close();</span><br><span class="line">bin.close();</span><br><span class="line">System.out.println(BufferedInputFile.read(desfilename));</span><br></pre></td></tr></table></figure>

<h2 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a><font size="5">存储和恢复数据</font></h2><p>PrintWriter可以对数据进行格式化，以便我们阅读。但是为了输出可供另一个流恢复的数据，我们需要使用DataOutputStream写入数据，并用DataInputStream恢复数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//创建DataOutputStream对象，传递缓冲字节流</span><br><span class="line">DataOutputStream out = new DataOutputStream(</span><br><span class="line">		new BufferedOutputStream(</span><br><span class="line">				new FileOutputStream(&quot;.\\src\\eighteenth\\storingandrecoveringdata\\Data.txt&quot;)));</span><br><span class="line">out.writeDouble(3.1415926535);</span><br><span class="line">out.writeUTF(&quot;That was Pi&quot;);</span><br><span class="line">out.writeDouble(1.41413);</span><br><span class="line">out.writeUTF(&quot;Square root of 2&quot;);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">//创建DataInputStream对象，传递缓冲字节流</span><br><span class="line">DataInputStream in = new DataInputStream(</span><br><span class="line">		new BufferedInputStream(</span><br><span class="line">				new FileInputStream(&quot;.\\src\\eighteenth\\storingandrecoveringdata\\Data.txt&quot;)));</span><br><span class="line"></span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br></pre></td></tr></table></figure>

<p>使用这一对流，在一台机器上写入，无论在哪一台机器上读取写入的结果，都是准确的，因为它们以和机器无关的方式读写数据。</p>
<h1 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h1><p>按照标准I/O模型，Java提供了Syatem.in、System.out、System.err。</p>
<ol>
<li>System.out已经被事先包装成了PrintStream对象，可以进行格式化输出，将数据打印到控制台。</li>
<li>Systeam.err也是PrintStream对象</li>
<li>Syatem.in是一个未被包装过的未经加工的InputStream对象。</li>
</ol>
<p>这意味着我们可以直接使用前两个输出流，但是在使用System.in时必须对其进行包装。</p>
<h2 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a><font size="5">从标准输入中读取</font></h2><p>一般我们使用readLine()进行一行一行的读取，因此，我们将System.in包装成BufferedReader。由字节流转换为字符流，我们需要使用InputStreamReader。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//利用System.in创建字符缓冲输入流对象</span><br><span class="line">BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">String s;</span><br><span class="line">//读取控制台输入的字符，并通过System.out回显到控制台中</span><br><span class="line">while ((s = stdin.readLine()) != null &amp;&amp; s.length() != 0) &#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“=======================”</span><br><span class="line">Output：</span><br><span class="line">qwert</span><br><span class="line">qwert</span><br></pre></td></tr></table></figure>

<h2 id="将System-out转换为PrintWriter"><a href="#将System-out转换为PrintWriter" class="headerlink" title="将System.out转换为PrintWriter"></a><font size="5">将System.out转换为PrintWriter</font></h2><p>System.out是一个PrintStream，而PrintStream是一个OutputStream。PrintWriter有一个接收OutputStream对象的构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用两个参数的构造器，并将第二个设置为true，一边开启自动刷新功能，否则会看不到输出</span><br><span class="line">PrintWriter pw = new PrintWriter(System.out, true);</span><br><span class="line">	pw.println(&quot;hello,world&quot;);</span><br><span class="line">	//如果采用一个参数的构造器，那么在之后要关闭流，才能将pw中的数据刷新到控制台</span><br><span class="line">	//pw.close()</span><br></pre></td></tr></table></figure>

<h2 id="标准I-O重定向"><a href="#标准I-O重定向" class="headerlink" title="标准I/O重定向"></a><font size="5">标准I/O重定向</font></h2><p>Java的System类提供了一些简单地静态方法，以支持我们对标准输入的、输出、错误I/O流进行重定向</p>
<ol>
<li>setIn(InputStream)</li>
<li>setOut(PrintStream)</li>
<li>setErr(PrintStream)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//保存控制台标准输出流的引用</span><br><span class="line">PrintStream console = System.out;</span><br><span class="line"></span><br><span class="line">//创建缓冲字节输入流</span><br><span class="line">BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;.\\src\\eighteenth\\redirecting\\Redirceting.java&quot;));</span><br><span class="line">//创建格式化流</span><br><span class="line">PrintStream out = new PrintStream(</span><br><span class="line">		new BufferedOutputStream(</span><br><span class="line">				new FileOutputStream(&quot;.\\src\\eighteenth\\redirecting\\test.out&quot;)));</span><br><span class="line"></span><br><span class="line">//经标准输入流重定向到Redirceting.java</span><br><span class="line">//将标准输出流重定向到test.out</span><br><span class="line">// 将错误流也重定向到test.out</span><br><span class="line">System.setIn(in);</span><br><span class="line">System.setOut(out);</span><br><span class="line">System.setErr(out);</span><br><span class="line"></span><br><span class="line">//利用标准IO将一个文件的数据拷贝到另一个文件中</span><br><span class="line">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">String s;</span><br><span class="line">while ((s = br.readLine()) != null) &#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">//关闭重定向的输出流</span><br><span class="line">out.close();</span><br><span class="line">//将标准输出流恢复到控制台</span><br><span class="line">System.setOut(console);</span><br></pre></td></tr></table></figure>

<p>I/O重定向操纵的是字节流，而不是字符流。</p>
<h1 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h1><p>见Java编程思想和API类库</p>
<hr>











    </div>

    
    
    
	<div>
	
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束 <i class="fa fa-paw"></i> 感谢您的阅读-------------</div>
    
</div>

	
	</div>
	<div>
      
        
      
	</div>
        
      
        <div id="reward-container">
  <div>如果你喜欢，请我喝杯茶呗...</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="郭源潮 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/读书笔记/" rel="tag"><i class="fa fa-tag"></i>读书笔记</a>
            
              <a href="/tags/I-O/" rel="tag"><i class="fa fa-tag"></i>I/O</a>
            
              <a href="/tags/Java基础/" rel="tag"><i class="fa fa-tag"></i>Java基础</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/10/26/买股票的最佳时机/" rel="next" title="买股票的最佳时机">
                  <i class="fa fa-chevron-left"></i> 买股票的最佳时机
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/10/27/相交链表/" rel="prev" title="相交链表">
                  相交链表 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#输入和输出"><span class="nav-number">1.</span> <span class="nav-text">输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InputStream类型"><span class="nav-number">1.1.</span> <span class="nav-text">InputStream类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ByteArrayInputStream"><span class="nav-number">1.1.1.</span> <span class="nav-text">ByteArrayInputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileInputStream"><span class="nav-number">1.1.2.</span> <span class="nav-text">FileInputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PipedInputStream"><span class="nav-number">1.1.3.</span> <span class="nav-text">PipedInputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SequenceInputStream"><span class="nav-number">1.1.4.</span> <span class="nav-text">SequenceInputStream</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OutputStream类型"><span class="nav-number">1.2.</span> <span class="nav-text">OutputStream类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ByteArrayOutputStream"><span class="nav-number">1.2.1.</span> <span class="nav-text">ByteArrayOutputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileOutputStream"><span class="nav-number">1.2.2.</span> <span class="nav-text">FileOutputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PipedOutputStream"><span class="nav-number">1.2.3.</span> <span class="nav-text">PipedOutputStream</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#添加属性和有用的接口"><span class="nav-number">2.</span> <span class="nav-text">添加属性和有用的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通过FilterInputStream从InputStream读取数据"><span class="nav-number">2.1.</span> <span class="nav-text">通过FilterInputStream从InputStream读取数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DataInputStream"><span class="nav-number">2.1.1.</span> <span class="nav-text">DataInputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferedInputStream"><span class="nav-number">2.1.2.</span> <span class="nav-text">BufferedInputStream</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过FilterOutputStream从OutputStream读取数据"><span class="nav-number">2.2.</span> <span class="nav-text">通过FilterOutputStream从OutputStream读取数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DataOutputStream"><span class="nav-number">2.2.1.</span> <span class="nav-text">DataOutputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PrintStream"><span class="nav-number">2.2.2.</span> <span class="nav-text">PrintStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BufferedOutputStream"><span class="nav-number">2.2.3.</span> <span class="nav-text">BufferedOutputStream</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reader和Writer"><span class="nav-number">3.</span> <span class="nav-text">Reader和Writer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更改流的行为"><span class="nav-number">4.</span> <span class="nav-text">更改流的行为</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RandomAccessFle"><span class="nav-number">5.</span> <span class="nav-text">RandomAccessFle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-O的典型使用方式"><span class="nav-number">6.</span> <span class="nav-text">I/O的典型使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲输入文件"><span class="nav-number">6.1.</span> <span class="nav-text">缓冲输入文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从内存输入"><span class="nav-number">6.2.</span> <span class="nav-text">从内存输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化内存输入"><span class="nav-number">6.3.</span> <span class="nav-text">格式化内存输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本的文件输出"><span class="nav-number">6.4.</span> <span class="nav-text">基本的文件输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件输出快捷方式"><span class="nav-number">6.5.</span> <span class="nav-text">文件输出快捷方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储和恢复数据"><span class="nav-number">6.6.</span> <span class="nav-text">存储和恢复数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准I-O"><span class="nav-number">7.</span> <span class="nav-text">标准I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从标准输入中读取"><span class="nav-number">7.1.</span> <span class="nav-text">从标准输入中读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将System-out转换为PrintWriter"><span class="nav-number">7.2.</span> <span class="nav-text">将System.out转换为PrintWriter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准I-O重定向"><span class="nav-number">7.3.</span> <span class="nav-text">标准I/O重定向</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列化流"><span class="nav-number">8.</span> <span class="nav-text">序列化流</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/pic.jpg"
      alt="郭源潮">
  <p class="site-author-name" itemprop="name">郭源潮</p>
  <div class="site-description" itemprop="description">时间在无声的诉说着一切</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">193</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">175</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/guoyuanchao1202" title="GitHub &rarr; https://github.com/guoyuanchao1202" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:932552424@qq.com" title="E-Mail &rarr; mailto:932552424@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/u/6273792268?is_all=1" title="Weibo &rarr; https://weibo.com/u/6273792268?is_all=1" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.w3school.com.cn/tags/tag_ul.asp" title="https://www.w3school.com.cn/tags/tag_ul.asp" rel="noopener" target="_blank">w3school</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭源潮</span>
</div>
	<div class="powered-by">
	<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
	  本站访客数:<span id="busuanzi_value_site_uv"></span>
	  <span id="busuanzi_container_site_pv">
	  本站总访问量<span id="busuanzi_value_site_pv"></span>次
	  </span>
	</span>
	</div>
<!--

  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>
-->

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='96,96,96' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

 
  <script type = "text/javascript"  src ="dist/canvas-nest.js"> </script>
 
</body>
</html>
